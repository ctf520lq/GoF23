• 工厂模式：
	 – 实现了创建者和调用者的分离。
	  – 详细分类： 
	  	• 简单工厂模式 
	  	• 工厂方法模式 
	  	• 抽象工厂模式
	  	
• 面向对象设计的基本原则：
	 – OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开 放，对修改关闭。 
	 - DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程， 不要针对实现编程。 
	 - LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和 陌生人通信。

• 核心本质： 
	– 实例化对象，用工厂方法代替new操作。 
	– 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实 现类解耦。 
	
• 工厂模式： 
	– 简单工厂模式 
		• 用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已 有代码）
	– 工厂方法模式 
		• 用来生产同一等级结构中的固定产品。（支持增加任意产品）
	 – 抽象工厂模式 
	 	• 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持 增加产品族）

• 简单工厂模式:
	• 要点： 
		– 简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法， 通过接收的参数的不同来返回不同的对象实例。 
		– 对于增加新产品无能为力！不修改代码的话，是无法扩展的。

• 工厂方法模式:
	• 要点： 
		– 为了避免简单工厂模式的缺点，不完全满足OCP。 
		– 工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目 或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。

• 简单工厂模式和工厂方法模式PK: 
	– 结构复杂度:
		从这个角度比较，显然简单工厂模式要占优。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个 数增加而增加，
		这无疑会使类的个数越来越多，从而增加了结构的复杂程度。 
	– 代码复杂度 
		代码复杂度和结构复杂度是一对矛盾，既然简单工厂模式在结构方面相对简洁，那么它在代码方面肯定是比工厂方法 模式复杂的了。
		简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工 厂类只完成单一任务，代码简洁。 
	– 客户端编程难度 
		工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。
		而简 单工厂模式的工厂类是个静态类，在客户端无需实例化，这无疑是个吸引人的优点。 – 管理上的难度 这是个关键的问题。 
		我们先谈扩展。众所周知，工厂方法模式完全满足OCP，即它有非常良好的扩展性。那是否就说明了简单工厂模式就 没有扩展性呢？
		答案是否定的。简单工厂模式同样具备良好的扩展性——扩展的时候仅需要修改少量的代码（修改工 厂类的代码）就可以满足扩展性的要求了。
		尽管这没有完全满足OCP，但我们不需要太拘泥于设计理论，要知道， sun提供的java官方工具包中也有想到多没有满足OCP的例子啊。 
		然后我们从维护性的角度分析下。假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时 需要修改多个产品类的时候，
		对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。反而简单工厂没有这些 麻烦，当多个产品类需要修改是，
		简单工厂模式仍然仅仅需要修改唯一的工厂类（无论怎样都能改到满足要求吧？大 不了把这个类重写）。 
• 根据设计理论建议：工厂方法模式。但实际上，我们一般都用简单工厂模式。

• 抽象工厂模式 
	– 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力； 支持增加产品族）
	– 抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务 分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。

• 工厂模式要点： 
	– 简单工厂模式(静态工厂模式) • 虽然某种程度不符合设计原则，但实际使用最多。 
	– 工厂方法模式 • 不修改已有类的前提下，通过增加新的工厂类实现扩展。 
	– 抽象工厂模式 • 不可以增加产品，可以增加产品族！ 

• 应用场景 
	– JDK中Calendar的getInstance方法 
	– JDBC中Connection对象的获取 
	– Hibernate中SessionFactory创建Session 
	– spring中IOC容器创建管理bean对象 
	– XML解析时的DocumentBuilderFactory创建解析器对象 
	– 反射中Class对象的newInstance()
		